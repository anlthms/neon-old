# ----------------------------------------------------------------------------
# Copyright 2014 Nervana Systems Inc.  All rights reserved.
# ----------------------------------------------------------------------------
# Experiment settings to train/test a Balance Neural Net on full
# MNIST.

 # !obj:experiments.GenOutputExperiment {
!obj:experiments.FitPredictErrorExperiment {
  # zparam: 0.0,
  # olayout: [12, 6],
  # fshape: [28, 28],
  # figure_filename: 'ofn.png',

  dataset: &ds !obj:datasets.Imageset {
    repo_path: '~/data',
    save_dir: '~/data/MULTIPIE-frontal/batch_data/',
    label_list: ['l_sub', 'l_exp', 'l_ill', 'l_cam'],
    cropped_image_size: &cis 96,
    output_image_size: *cis,
    output_batch_size: 7168,
    num_train_macro_batches: 14, #max available train macro_batches
    ring_buffer_size: 3,
    num_processes: 3,
    # macro batch start and end indices to use for train and val datasets
    start_train: 0,
    end_train: 10,
  },

  lrule: &adad {
    type: adadelta,
    lr_params: {
      epsilon: 0.000001,
      rho: 0.95,
    },
  },

  wt_cfgs: [
    &wt_init_a !obj:params.AutoUniformValGen {
      # bias_init: 0.0,
    },
    &wt_init_b !obj:params.AutoUniformValGen {
      # bias_init: 0.0,
      relu: 1,
    },
  ],

  # simple Balance model specification
  model: !obj:models.BalanceMP {
    # serialized_path: './balance-simple.pkl',
    num_epochs: 20,
    # step_print: 256,
    step_print: 24,
    batch_size: &bs 128,
    layers: [
      &datalayer !obj:layers.ImageDataLayer {
        name: d0,
        is_local: True,
        nofm: 3,
        ofmshape: [*cis, *cis],
      },
      &conv1 !obj:layers.ConvLayer {
        name: conv1,
        lrule_init: *adad,
        weight_init: *wt_init_a,
        nofm: 32,
        fshape: [7, 7],
        stride: 3,
        activation: !obj:transforms.RectLin {},
      },
      &pool1 !obj:layers.PoolingLayer {
        name: pool1,
        op: 'max',
        fshape: [3, 3],
        stride: 2,
      },
      &conv2 !obj:layers.ConvLayer {
        name: conv2,
        lrule_init: *adad,
        weight_init: *wt_init_a,
        nofm: 64,
        fshape: [5, 5],
        activation: !obj:transforms.RectLin {},
      },
      &pool2 !obj:layers.PoolingLayer {
        name: pool2,
        op: 'max',
        fshape: [2, 2],
      },
      &conv3 !obj:layers.ConvLayer {
        name: conv3,
        lrule_init: *adad,
        weight_init: *wt_init_a,
        nofm: 128,
        fshape: [3, 3],
        activation: !obj:transforms.RectLin {},
      },
      &pool3 !obj:layers.PoolingLayer {
        name: pool3,
        op: 'max',
        fshape: [2, 2],
        stride: 2,
      },
      &h0 !obj:layers.FCLayer {
        name: h0,
        lrule_init: *adad,
        weight_init: *wt_init_b,
        activation: !obj:transforms.RectLin {},
        nout: 2000,
      },
      &blayer !obj:layers.BranchLayer {
        name: blayer,
        sublayers: [
          &zlayer !obj:layers.FCLayer {
            name: zlayer,
            lrule_init: *adad,
            weight_init: *wt_init_a,
            nout: 800,
          },
          &subjectlayer !obj:layers.FCLayer {
            name: subjectlayer,
            lrule_init: *adad,
            weight_init: *wt_init_a,
            nout: 346,
            activation: !obj:transforms.Softmax {},
          },
          # &illumlayer !obj:layers.FCLayer {
          #   name: illumlayer,
          #   lrule_init: *adad,
          #   weight_init: *wt_init_a,
          #   nout: 20,
          #   activation: !obj:transforms.Softmax {},
          # },
          # &camlayer !obj:layers.FCLayer {
          #   name: camlayer,
          #   lrule_init: *adad,
          #   weight_init: *wt_init_a,
          #   nout: 3,
          #   activation: !obj:transforms.Softmax {},
          # },
          &exprlayer !obj:layers.FCLayer {
            name: exprlayer,
            lrule_init: *adad,
            weight_init: *wt_init_a,
            nout: 6,
            activation: !obj:transforms.Softmax {},
          },
        ],
      },
      &h3 !obj:layers.FCLayer {
        name: h3,
        lrule_init: *adad,
        weight_init: *wt_init_a,
        nout: 4608,
        activation: !obj:transforms.RectLin {},
      },
      &unpool1 !obj:layers.UnPoolingLayer {
        name: unpool1,
        ifmshape: [6, 6],
        nifm: 128,
        fshape: [2, 2],
        stride: 2,
      },
      &dconv1 !obj:layers.ConvLayer {
        name: dconv1,
        lrule_init: *adad,
        weight_init: *wt_init_a,
        nofm: 128,
        fshape: [5, 5],
        pad: 2,
        activation: !obj:transforms.RectLin {},
      },
      &unpool2 !obj:layers.UnPoolingLayer {
        name: unpool2,
        fshape: [2, 2],
        stride: 2,
      },
      &dconv2 !obj:layers.ConvLayer {
        name: dconv2,
        lrule_init: *adad,
        weight_init: *wt_init_a,
        nofm: 64,
        fshape: [5, 5],
        pad: 2,
        activation: !obj:transforms.RectLin {},
      },
      &unpool3 !obj:layers.UnPoolingLayer {
        name: unpool3,
        fshape: [4, 4],
        stride: 4,
      },
      &dconv3 !obj:layers.SubConvLayer {
        name: dconv3,
        lrule_init: *adad,
        weight_init: *wt_init_a,
        nofm: 16,
        fshape: [5, 5],
        pad: 2,
        endidx: 3,
        activation: !obj:transforms.RectLin {},
      },
      # &dconv3 !obj:layers.ConvLayer {
      #   name: dconv3,
      #   lrule_init: *adad,
      #   weight_init: *wt_init_a,
      #   nofm: 16,
      #   fshape: [5, 5],
      #   pad: 2,
      #   activation: !obj:transforms.RectLin {},
      # },
      # !obj:layers.SliceLayer {
      #   name: slice,
      #   end_idx: 3,
      # },
      &sumsqcostlayer !obj:layers.CostLayer {
        name: sumsqcost,
        olayer_data: 'suboutput',
        ref_layer: *datalayer,
        ref_label: 'output',
        cost: !obj:transforms.SumSquaredDiffs {},
      },
    ],
    prefixlayers: [
      *datalayer,
      *conv1, *pool1,
      *conv2, *pool2,
      *conv3, *pool3,
      *h0,
    ],
    costpaths: {
      subject: [
        *subjectlayer,
        !obj:layers.CostLayer {
          name: subcost,
          ref_layer: *datalayer,
          ref_label: 'labels',
          raw_label: True,
          category_label: 'l_sub',
          cost: !obj:transforms.CrossEntropy {},
        },
      ],
      # illum: [
      #   *illumlayer,
      #   !obj:layers.CostLayer {
      #     name: cost,
      #     ref_layer: *datalayer,
      #     ref_label: 'labels',
      #     raw_label: True,
      #     category_label: 'l_ill',
      #     cost: !obj:transforms.CrossEntropy {},
      #   },
      # ],
      expr: [
        *exprlayer,
        !obj:layers.CostLayer {
          name: expcost,
          ref_layer: *datalayer,
          ref_label: 'labels',
          raw_label: True,
          category_label: 'l_exp',
          cost: !obj:transforms.CrossEntropy {},
        },
      ],
      # cam: [
      #   *camlayer,
      #   !obj:layers.CostLayer {
      #     name: cost,
      #     ref_layer: *datalayer,
      #     ref_label: 'labels',
      #     raw_label: True,
      #     category_label: 'l_cam',
      #     cost: !obj:transforms.CrossEntropy {},
      #   },
      # ],
      z:  [
        *blayer,
        &xcovcostlayer !obj:layers.CostLayer {
          name: covcost,
          ref_layer: *datalayer,
          cost: !obj:neon.transforms.xcov.XCovariance {
            blkidx: 800,
            scale: 10,
          },
        },
      ],
    },
  },

  # logging options that are passed to logging.basicConfig
  # level value thresholds (set level lower to display them):
  #   CRITICAL 50
  #   ERROR    40
  #   WARNING  30
  #   INFO     20
  #   DEBUG    10
  #   NOTSET    0
  logging: {
    level: 20,
    format: '%(asctime)-15s %(levelname)s:%(module)s - %(message)s'
  },
}
